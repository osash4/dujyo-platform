//! CRITICAL SECURITY TESTS - Paranoid Mode
//! 
//! These tests verify EMPIRICALLY that the 4 critical exploits NO LONGER WORK.
//! Each test executes the ORIGINAL EXPLOIT and verifies it FAILS.
//!
//! IMPORTANT: These tests MUST FAIL if the exploits still work.

use std::sync::{Arc, Mutex};
use tokio::sync::Mutex as TokioMutex;
use axum::{
    body::Body,
    http::{Request, StatusCode, HeaderValue},
};
use tower::ServiceExt;
use serde_json::json;

use crate::server::{AppState, StreamEarnRequest, create_router};
use crate::blockchain::blockchain::{Blockchain, Transaction};
use crate::blockchain::token::Token;
use crate::storage::BlockchainStorage;
use crate::auth::{JwtConfig, Claims};
use crate::consensus::cpv::CPVConsensus;
use crate::dex::DEX;
use crate::payments::withdrawal_service::WithdrawalService;
use crate::compliance::kyc_service::KycService;
use sqlx::PgPool;

// Test helper: Create test AppState
async fn create_test_state() -> (AppState, PgPool) {
    // Use test database
    let database_url = std::env::var("TEST_DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://dujyo:dujyo_password@localhost:5432/dujyo_test".to_string());
    
    // Create test database pool
    let pool = sqlx::PgPool::connect(&database_url)
        .await
        .expect("Failed to create test database pool");
    
    // Initialize storage
    let storage = Arc::new(BlockchainStorage::new(&database_url).await.expect("Failed to create storage"));
    storage.init_tables().await.expect("Failed to init tables");
    
    // Create blockchain with test balance
    let blockchain = Arc::new(Mutex::new(Blockchain::new()));
    let token = Arc::new(Mutex::new(Token::new()));
    let dex = Arc::new(Mutex::new(DEX::new()));
    let websocket_clients = Arc::new(Mutex::new(Vec::new()));
    let jwt_config = JwtConfig::new();
    
    // Setup CPV consensus with database pool
    let mut cpv_consensus_instance = CPVConsensus::new();
    cpv_consensus_instance.set_db_pool(pool.clone());
    let cpv_consensus = Arc::new(TokioMutex::new(cpv_consensus_instance));
    
    let state = AppState {
        blockchain: blockchain.clone(),
        token: token.clone(),
        dex: dex.clone(),
        websocket_clients,
        storage: storage.clone(),
        jwt_config,
        cpv_consensus,
    };
    
    (state, pool)
}

// Test helper: Create test JWT token
fn create_test_token(address: &str) -> String {
    let jwt_config = JwtConfig::new();
    jwt_config.generate_token(address).expect("Failed to generate token")
}

// Test helper: Create test user with balance
async fn create_test_user_with_balance(
    state: &AppState,
    address: &str,
    balance_dyo: u64,
) {
    let mut blockchain = state.blockchain.lock().unwrap();
    let genesis_tx = Transaction {
        from: "GENESIS".to_string(),
        to: address.to_string(),
        amount: balance_dyo * 100, // Convert to cents
        nft_id: None,
    };
    blockchain.add_transaction(genesis_tx).expect("Failed to create test balance");
}

#[cfg(test)]
mod critical_security_tests {
    use super::*;
    use crate::server::StreamEarnRequest;
    use crate::routes::payments::WithdrawalRequestDto;
    use crate::routes::validator_registration::EconomicValidatorRequest;
    use std::time::Duration;
    use tokio::time::timeout;

    // ============================================================================
    // TEST #1: NONCE CLIENT CONTROL ATTACK FAILS
    // ============================================================================
    
    #[tokio::test]
    async fn test_nonce_client_control_attack_fails() {
        // SETUP: Create test state
        let (state, _pool) = create_test_state().await;
        let test_user = "XWTEST_USER_001";
        create_test_user_with_balance(&state, test_user, 1000).await;
        
        // Create test content in database
        let pool = &state.storage.pool;
        sqlx::query(
            r#"
            INSERT INTO content (content_id, artist_id, title, genre, created_at)
            VALUES ('test_track_001', $1, 'Test Track', 'Electronic', NOW())
            ON CONFLICT (content_id) DO NOTHING
            "#
        )
        .bind(test_user)
        .execute(pool)
        .await
        .expect("Failed to create test content");
        
        // Create JWT token
        let token = create_test_token(test_user);
        
        // EXPLOIT ATTEMPT #1: Send request with nonce generated by CLIENT
        let client_generated_nonce = "client_controlled_nonce_12345";
        let stream_request = StreamEarnRequest {
            type_: "listener".to_string(),
            duration_seconds: 60,
            track_id: Some("test_track_001".to_string()),
            track_title: Some("Test Track".to_string()),
            track_genre: Some("Electronic".to_string()),
            artist_id: Some(test_user.to_string()),
            artist_followers: Some(1000),
            shared_socially: Some(false),
            nonce: Some(client_generated_nonce.to_string()), // ❌ CLIENT CONTROLS NONCE
            content_hash: None,
        };
        
        // Create request
        let app = create_router(state.clone(), pool.clone());
        let request = Request::builder()
            .method("POST")
            .uri("/api/v1/stream-earn")
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(Body::from(serde_json::to_string(&stream_request).unwrap()))
            .unwrap();
        
        // Execute request
        let response = app.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::OK);
        
        let response_body = hyper::body::to_bytes(response.into_body()).await.unwrap();
        let response_json: serde_json::Value = serde_json::from_slice(&response_body).unwrap();
        
        // ✅ VERIFICATION #1: Request should succeed (nonce is now server-generated)
        assert!(response_json["success"].as_bool().unwrap_or(false), 
            "Request should succeed even with client-provided nonce (server ignores it)");
        
        // ✅ VERIFICATION #2: Check database for nonce - should be DIFFERENT from client nonce
        let db_nonce: Option<String> = sqlx::query_scalar(
            "SELECT nonce FROM stream_nonces WHERE user_address = $1 ORDER BY created_at DESC LIMIT 1"
        )
        .bind(test_user)
        .fetch_optional(pool)
        .await
        .expect("Failed to query nonce");
        
        assert!(db_nonce.is_some(), "Nonce should be stored in database");
        let stored_nonce = db_nonce.unwrap();
        
        // ✅ VERIFICATION #3: Stored nonce should be DIFFERENT from client-provided nonce
        // This proves server generated its own nonce
        assert_ne!(stored_nonce, client_generated_nonce,
            "Server should generate its own nonce, not use client-provided nonce");
        
        // ✅ VERIFICATION #4: Stored nonce should be 32-character hex (128 bits)
        assert_eq!(stored_nonce.len(), 32,
            "Server-generated nonce should be 32 characters (128 bits)");
        assert!(stored_nonce.chars().all(|c| c.is_ascii_hexdigit()),
            "Server-generated nonce should be hexadecimal");
        
        println!("✅ TEST PASSED: Nonce client control attack FAILS - Server generates its own nonce");
    }

    // ============================================================================
    // TEST #2: NONCE TOCTOU ATTACK FAILS
    // ============================================================================
    
    #[tokio::test]
    async fn test_nonce_toctou_attack_fails() {
        // SETUP: Create test state
        let (state, _pool) = create_test_state().await;
        let test_user = "XWTEST_USER_002";
        create_test_user_with_balance(&state, test_user, 1000).await;
        
        // Create test content
        let pool = &state.storage.pool;
        sqlx::query(
            r#"
            INSERT INTO content (content_id, artist_id, title, genre, created_at)
            VALUES ('test_track_002', $1, 'Test Track 2', 'Electronic', NOW())
            ON CONFLICT (content_id) DO NOTHING
            "#
        )
        .bind(test_user)
        .execute(pool)
        .await
        .expect("Failed to create test content");
        
        // Create JWT token
        let token = create_test_token(test_user);
        
        // EXPLOIT ATTEMPT: Send 2 CONCURRENT requests (simulating TOCTOU attack)
        // Note: Since nonce is now server-generated, we can't control it directly
        // But we can test that concurrent requests with same content don't cause issues
        
        let app = create_router(state.clone(), pool.clone());
        
        // Create two identical requests (nonce will be generated server-side)
        let stream_request = StreamEarnRequest {
            type_: "listener".to_string(),
            duration_seconds: 60,
            track_id: Some("test_track_002".to_string()),
            track_title: Some("Test Track 2".to_string()),
            track_genre: Some("Electronic".to_string()),
            artist_id: Some(test_user.to_string()),
            artist_followers: Some(1000),
            shared_socially: Some(false),
            nonce: None, // Server will generate
            content_hash: None,
        };
        
        // Send 2 concurrent requests
        let request1 = Request::builder()
            .method("POST")
            .uri("/api/v1/stream-earn")
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(Body::from(serde_json::to_string(&stream_request).unwrap()))
            .unwrap();
        
        let request2 = Request::builder()
            .method("POST")
            .uri("/api/v1/stream-earn")
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(Body::from(serde_json::to_string(&stream_request).unwrap()))
            .unwrap();
        
        // Execute both requests concurrently
        let (response1, response1) = app.clone().oneshot(request1).await.unwrap();
        let (response2, response2) = app.oneshot(request2).await.unwrap();
        
        // ✅ VERIFICATION #1: Both requests should succeed (different nonces generated)
        assert_eq!(response1.status(), StatusCode::OK);
        assert_eq!(response2.status(), StatusCode::OK);
        
        let response1_body = hyper::body::to_bytes(response1.into_body()).await.unwrap();
        let response2_body = hyper::body::to_bytes(response2.into_body()).await.unwrap();
        
        let response1_json: serde_json::Value = serde_json::from_slice(&response1_body).unwrap();
        let response2_json: serde_json::Value = serde_json::from_slice(&response2_body).unwrap();
        
        // ✅ VERIFICATION #2: Both should have success = true
        assert!(response1_json["success"].as_bool().unwrap_or(false),
            "First concurrent request should succeed");
        assert!(response2_json["success"].as_bool().unwrap_or(false),
            "Second concurrent request should succeed");
        
        // ✅ VERIFICATION #3: Check database - should have 2 DIFFERENT nonces
        let nonces: Vec<String> = sqlx::query_scalar(
            "SELECT nonce FROM stream_nonces WHERE user_address = $1 ORDER BY created_at DESC LIMIT 2"
        )
        .bind(test_user)
        .fetch_all(pool)
        .await
        .expect("Failed to query nonces");
        
        assert_eq!(nonces.len(), 2, "Should have 2 nonces for 2 requests");
        
        // ✅ VERIFICATION #4: Nonces should be DIFFERENT (proves atomic insertion works)
        assert_ne!(nonces[0], nonces[1],
            "Concurrent requests should generate different nonces");
        
        // ✅ VERIFICATION #5: Both nonces should be unique in database
        let unique_nonces: i64 = sqlx::query_scalar(
            "SELECT COUNT(DISTINCT nonce) FROM stream_nonces WHERE user_address = $1"
        )
        .bind(test_user)
        .fetch_one(pool)
        .await
        .expect("Failed to count unique nonces");
        
        assert_eq!(unique_nonces, 2,
            "All nonces should be unique (no collisions)");
        
        println!("✅ TEST PASSED: Nonce TOCTOU attack FAILS - Atomic insertion prevents collisions");
    }

    // ============================================================================
    // TEST #3: CONCURRENT WITHDRAWAL ATTACK FAILS
    // ============================================================================
    
    #[tokio::test]
    async fn test_concurrent_withdrawal_attack_fails() {
        // SETUP: Create test state
        let (state, _pool) = create_test_state().await;
        let test_user = "XWTEST_USER_003";
        let initial_balance_dyo = 100;
        create_test_user_with_balance(&state, test_user, initial_balance_dyo).await;
        
        // Create JWT token
        let token = create_test_token(test_user);
        
        // Setup withdrawal service and KYC
        let withdrawal_service = Arc::new(WithdrawalService::new());
        let kyc_service = Arc::new(KycService::new());
        
        // Mark user as KYC verified
        kyc_service.verify_user(test_user).await;
        
        // EXPLOIT ATTEMPT: Send 2 CONCURRENT withdrawal requests for 100 DYO each
        // User has 100 DYO, so only ONE should succeed
        
        let withdrawal_request = WithdrawalRequestDto {
            amount: 100.0, // Try to withdraw full balance
            currency: "DYO".to_string(),
            destination: crate::routes::payments::WithdrawalDestinationRequest {
                destination_type: "crypto".to_string(),
                address: Some("WITHDRAWAL_ADDRESS".to_string()),
                network: Some("ethereum".to_string()),
                account_number: None,
                routing_number: None,
                account_type: None,
                stripe_account_id: None,
            },
            memo: None,
        };
        
        let app = create_router(state.clone(), state.storage.pool.clone());
        
        // Create two identical withdrawal requests
        let request1 = Request::builder()
            .method("POST")
            .uri("/api/v1/payments/withdraw")
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(Body::from(serde_json::to_string(&withdrawal_request).unwrap()))
            .unwrap();
        
        let request2 = Request::builder()
            .method("POST")
            .uri("/api/v1/payments/withdraw")
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(Body::from(serde_json::to_string(&withdrawal_request).unwrap()))
            .unwrap();
        
        // Execute both requests concurrently (with timeout to prevent hanging)
        let app_clone = app.clone();
        let handle1 = tokio::spawn(async move {
            timeout(Duration::from_secs(5), app_clone.oneshot(request1))
                .await
                .expect("Request 1 timeout")
                .expect("Request 1 failed")
        });
        
        let handle2 = tokio::spawn(async move {
            timeout(Duration::from_secs(5), app.oneshot(request2))
                .await
                .expect("Request 2 timeout")
                .expect("Request 2 failed")
        });
        
        let (response1, response2) = tokio::join!(handle1, handle2);
        let response1 = response1.unwrap();
        let response2 = response2.unwrap();
        
        // ✅ VERIFICATION #1: At least one request should succeed
        assert_eq!(response1.status(), StatusCode::OK);
        assert_eq!(response2.status(), StatusCode::OK);
        
        let response1_body = hyper::body::to_bytes(response1.into_body()).await.unwrap();
        let response2_body = hyper::body::to_bytes(response2.into_body()).await.unwrap();
        
        let response1_json: serde_json::Value = serde_json::from_slice(&response1_body).unwrap();
        let response2_json: serde_json::Value = serde_json::from_slice(&response2_body).unwrap();
        
        // ✅ VERIFICATION #2: Only ONE request should have success = true
        let success1 = response1_json["success"].as_bool().unwrap_or(false);
        let success2 = response2_json["success"].as_bool().unwrap_or(false);
        
        assert!(success1 || success2, "At least one request should succeed");
        assert!(!(success1 && success2), 
            "Both requests should NOT succeed - only one should process");
        
        // ✅ VERIFICATION #3: One request should fail with "Insufficient balance"
        let failed_message = if !success1 {
            response1_json["message"].as_str().unwrap_or("")
        } else {
            response2_json["message"].as_str().unwrap_or("")
        };
        
        assert!(failed_message.contains("Insufficient balance") || 
                failed_message.contains("balance"),
            "Failed request should indicate insufficient balance");
        
        // ✅ VERIFICATION #4: Check final balance - should be 0 (not negative)
        let final_balance = {
            let blockchain = state.blockchain.lock().unwrap();
            blockchain.get_balance(test_user) as f64 / 100.0
        };
        
        assert!(final_balance >= 0.0, 
            "Final balance should NOT be negative. Got: {}", final_balance);
        assert!(final_balance < initial_balance_dyo as f64,
            "Balance should be reduced by one withdrawal");
        
        // ✅ VERIFICATION #5: Only ONE blockchain transaction should exist
        let blockchain = state.blockchain.lock().unwrap();
        let withdrawal_txs: Vec<&Transaction> = blockchain.pending_transactions
            .iter()
            .filter(|tx| tx.from == test_user && tx.to == "WITHDRAWAL_ADDRESS")
            .collect();
        
        assert!(withdrawal_txs.len() <= 1,
            "Should have at most 1 withdrawal transaction. Got: {}", withdrawal_txs.len());
        
        println!("✅ TEST PASSED: Concurrent withdrawal attack FAILS - Only one withdrawal processed");
    }

    // ============================================================================
    // TEST #4: STAKE VERIFICATION BYPASS FAILS
    // ============================================================================
    
    #[tokio::test]
    async fn test_stake_verification_bypass_fails() {
        // SETUP: Create test state
        let (state, _pool) = create_test_state().await;
        let test_user = "XWTEST_USER_004";
        // CRITICAL: User has 0 DYO balance
        // Do NOT create balance for this user
        
        // Create JWT token
        let token = create_test_token(test_user);
        
        // EXPLOIT ATTEMPT: Try to register as validator with stake = 1000 DYO
        // User has 0 DYO, so registration should FAIL
        
        let validator_request = EconomicValidatorRequest {
            stake: Some(1000), // Try to stake 1000 DYO
        };
        
        let app = create_router(state.clone(), state.storage.pool.clone());
        let request = Request::builder()
            .method("POST")
            .uri("/api/v1/consensus/register/economic")
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(Body::from(serde_json::to_string(&validator_request).unwrap()))
            .unwrap();
        
        let response = app.oneshot(request).await.unwrap();
        assert_eq!(response.status(), StatusCode::OK);
        
        let response_body = hyper::body::to_bytes(response.into_body()).await.unwrap();
        let response_json: serde_json::Value = serde_json::from_slice(&response_body).unwrap();
        
        // ✅ VERIFICATION #1: Registration should FAIL
        assert!(!response_json["success"].as_bool().unwrap_or(true),
            "Registration should FAIL for user with insufficient balance");
        
        // ✅ VERIFICATION #2: Error message should indicate insufficient balance
        let error_message = response_json["message"].as_str().unwrap_or("");
        assert!(error_message.contains("Insufficient blockchain balance") ||
                error_message.contains("balance"),
            "Error message should indicate insufficient balance. Got: {}", error_message);
        
        // ✅ VERIFICATION #3: NO stake should be locked in database
        let pool = &state.storage.pool;
        let locked_stake: Option<i64> = sqlx::query_scalar(
            "SELECT stake_amount FROM validator_stakes WHERE validator_address = $1 AND is_active = TRUE"
        )
        .bind(test_user)
        .fetch_optional(pool)
        .await
        .expect("Failed to query stake");
        
        assert!(locked_stake.is_none(),
            "NO stake should be locked for user with insufficient balance");
        
        // ✅ VERIFICATION #4: NO validator should be registered
        let consensus = state.cpv_consensus.lock().await;
        assert!(!consensus.economic_validators.contains_key(test_user),
            "User should NOT be registered as validator");
        
        println!("✅ TEST PASSED: Stake verification bypass FAILS - User without balance cannot register");
    }
    
    #[tokio::test]
    async fn test_concurrent_validator_registration_fails() {
        // SETUP: Create test state
        let (state, _pool) = create_test_state().await;
        let test_user = "XWTEST_USER_005";
        let stake_amount = 1000;
        create_test_user_with_balance(&state, test_user, stake_amount).await;
        
        // Create JWT token
        let token = create_test_token(test_user);
        
        // EXPLOIT ATTEMPT: Send 2 CONCURRENT registration requests
        let validator_request = EconomicValidatorRequest {
            stake: Some(stake_amount),
        };
        
        let app = create_router(state.clone(), state.storage.pool.clone());
        
        let request1 = Request::builder()
            .method("POST")
            .uri("/api/v1/consensus/register/economic")
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(Body::from(serde_json::to_string(&validator_request).unwrap()))
            .unwrap();
        
        let request2 = Request::builder()
            .method("POST")
            .uri("/api/v1/consensus/register/economic")
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(Body::from(serde_json::to_string(&validator_request).unwrap()))
            .unwrap();
        
        // Execute both requests concurrently
        let app_clone = app.clone();
        let handle1 = tokio::spawn(async move {
            timeout(Duration::from_secs(5), app_clone.oneshot(request1))
                .await
                .expect("Request 1 timeout")
                .expect("Request 1 failed")
        });
        
        let handle2 = tokio::spawn(async move {
            timeout(Duration::from_secs(5), app.oneshot(request2))
                .await
                .expect("Request 2 timeout")
                .expect("Request 2 failed")
        });
        
        let (response1, response2) = tokio::join!(handle1, handle2);
        let response1 = response1.unwrap();
        let response2 = response2.unwrap();
        
        assert_eq!(response1.status(), StatusCode::OK);
        assert_eq!(response2.status(), StatusCode::OK);
        
        let response1_body = hyper::body::to_bytes(response1.into_body()).await.unwrap();
        let response2_body = hyper::body::to_bytes(response2.into_body()).await.unwrap();
        
        let response1_json: serde_json::Value = serde_json::from_slice(&response1_body).unwrap();
        let response2_json: serde_json::Value = serde_json::from_slice(&response2_body).unwrap();
        
        // ✅ VERIFICATION #1: Only ONE request should succeed
        let success1 = response1_json["success"].as_bool().unwrap_or(false);
        let success2 = response2_json["success"].as_bool().unwrap_or(false);
        
        assert!(success1 || success2, "At least one request should succeed");
        assert!(!(success1 && success2),
            "Both requests should NOT succeed - only one should register");
        
        // ✅ VERIFICATION #2: One request should fail with "Stake already locked"
        let failed_message = if !success1 {
            response1_json["message"].as_str().unwrap_or("")
        } else {
            response2_json["message"].as_str().unwrap_or("")
        };
        
        assert!(failed_message.contains("Stake already locked") ||
                failed_message.contains("already") ||
                failed_message.contains("conflict"),
            "Failed request should indicate stake already locked. Got: {}", failed_message);
        
        // ✅ VERIFICATION #3: Only ONE stake should be locked in database
        let pool = &state.storage.pool;
        let locked_stakes: Vec<(String, i64)> = sqlx::query_as(
            "SELECT validator_address, stake_amount FROM validator_stakes WHERE validator_address = $1 AND is_active = TRUE"
        )
        .bind(test_user)
        .fetch_all(pool)
        .await
        .expect("Failed to query stakes");
        
        assert_eq!(locked_stakes.len(), 1,
            "Should have exactly 1 locked stake. Got: {}", locked_stakes.len());
        
        // ✅ VERIFICATION #4: Only ONE validator should be registered
        let consensus = state.cpv_consensus.lock().await;
        let is_registered = consensus.economic_validators.contains_key(test_user);
        assert!(is_registered, "User should be registered as validator");
        
        println!("✅ TEST PASSED: Concurrent validator registration FAILS - Only one registration succeeds");
    }
}

