use axum::{
    extract::{Path, State, WebSocketUpgrade, Query},
    http::StatusCode,
    response::{Json, IntoResponse},
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::{Arc, Mutex};
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use tokio::time;
use tower_http::cors::CorsLayer;
use tower_http::timeout::TimeoutLayer;
use futures_util::{sink::SinkExt, stream::StreamExt};
use axum::extract::ws::{Message, WebSocket};

use crate::blockchain::blockchain::{Blockchain, Transaction, Block};
use crate::blockchain::token::Token;
use crate::blockchain::native_token::{NativeToken, VestingRequest};
use crate::blockchain::multisig::{MultisigWallet, MultisigRequest, SignRequest};
use crate::blockchain::vesting::{VestingManager, CreateVestingRequest, ReleaseVestingRequest};
use crate::blockchain::real_blockchain::RealBlockchain;
use crate::storage::BlockchainStorage;
use crate::auth::{JwtConfig, jwt_middleware, login_handler};
use crate::dex::DEX;
use crate::consensus::cpv::CPVConsensus;
use crate::handlers::wallet_handlers::{self, ConnectWalletRequest, ConnectWalletResponse, WalletSession};


// Shared state for the server
#[derive(Clone)]
pub struct AppState {
    pub blockchain: Arc<Mutex<Blockchain>>,
    pub token: Arc<Mutex<Token>>,
    pub dex: Arc<Mutex<DEX>>,
    pub websocket_clients: Arc<Mutex<Vec<axum::extract::ws::WebSocket>>>,
    pub storage: Arc<BlockchainStorage>,
    pub jwt_config: JwtConfig,
    pub cpv_consensus: Arc<Mutex<CPVConsensus>>,
    // Real blockchain implementation
    pub real_blockchain: Arc<Mutex<RealBlockchain>>,
    // Native functionalities
    pub native_token: Arc<Mutex<NativeToken>>,
    pub multisig_wallet: Arc<Mutex<MultisigWallet>>,
    pub vesting_manager: Arc<Mutex<VestingManager>>,
}

// Request/Response types
#[derive(Deserialize)]
pub struct TransactionRequest {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nft_id: Option<String>,
}

#[derive(Deserialize, Debug)]
pub struct ServerMintRequest {
    pub account: String,
    pub amount: f64,
}

#[derive(Serialize)]
pub struct TransactionResponse {
    pub success: bool,
    pub message: String,
    pub transaction_id: Option<String>,
}

#[derive(Serialize)]
pub struct BalanceResponse {
    pub address: String,
    pub balance: u64,
}

#[derive(Serialize)]
pub struct MintResponse {
    pub success: bool,
    pub message: String,
}

#[derive(Serialize)]
pub struct BlockResponse {
    pub blocks: Vec<Block>,
    pub total_blocks: usize,
}

// DEX structures
#[derive(Deserialize, Clone)]
pub struct SwapRequest {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub min_received: f64,
    pub user: String,
}

#[derive(Deserialize, Clone)]
pub struct LiquidityRequest {
    pub pool_id: String,
    pub amounts: Vec<f64>, // [amount_a, amount_b]
    pub user: String,
}

#[derive(Serialize)]
pub struct SwapResponse {
    pub success: bool,
    pub message: String,
    pub tx_hash: Option<String>,
    pub amount_received: Option<f64>,
    pub price_impact: Option<f64>,
}

#[derive(Serialize)]
pub struct LiquidityResponse {
    pub success: bool,
    pub message: String,
    pub tx_hash: Option<String>,
    pub lp_tokens_minted: Option<f64>,
}

#[derive(Serialize)]
pub struct PoolResponse {
    pub success: bool,
    pub pool: Option<serde_json::Value>,
    pub message: String,
}

// Handler functions
async fn get_blocks(State(state): State<AppState>) -> Result<Json<BlockResponse>, StatusCode> {
    let blockchain = state.blockchain.lock().unwrap();
    let blocks = blockchain.chain.clone();
    let total_blocks = blocks.len();
    
    Ok(Json(BlockResponse {
        blocks,
        total_blocks,
    }))
}

async fn get_transactions(State(state): State<AppState>) -> Result<Json<serde_json::Value>, StatusCode> {
    let blockchain = state.blockchain.lock().unwrap();
    let mut all_transactions = Vec::new();
    
    // Collect all transactions from all blocks
    for (block_index, block) in blockchain.chain.iter().enumerate() {
        for (tx_index, transaction) in block.transactions.iter().enumerate() {
            all_transactions.push(serde_json::json!({
                "id": format!("{}-{}", block_index, tx_index),
                "from": transaction.from,
                "to": transaction.to,
                "amount": transaction.amount,
                "nft_id": transaction.nft_id,
                "block_index": block_index,
                "block_hash": block.hash
            }));
        }
    }
    
    Ok(Json(serde_json::json!({
        "success": true,
        "transactions": all_transactions,
        "total": all_transactions.len(),
        "message": "Transactions retrieved successfully"
    })))
}

async fn get_token_stats(State(state): State<AppState>) -> Result<Json<serde_json::Value>, StatusCode> {
    let token = state.token.lock().unwrap();
    
    // Get basic token statistics using public method
    let (total_holders, total_balance, total_nfts, total_royalties) = token.get_stats();
    
    Ok(Json(serde_json::json!({
        "success": true,
        "name": "XWave Token",
        "symbol": "XWV",
        "total_holders": total_holders,
        "total_balance": total_balance,
        "total_nfts": total_nfts,
        "total_royalties": total_royalties,
        "message": "Token stats retrieved successfully"
    })))
}

async fn submit_transaction(
    State(state): State<AppState>,
    Json(request): Json<TransactionRequest>,
) -> Result<Json<TransactionResponse>, StatusCode> {
    let transaction = Transaction {
        from: request.from.clone(),
        to: request.to.clone(),
        amount: request.amount,
        nft_id: request.nft_id,
    };
    
    // Add transaction to blockchain (release lock before async operations)
    let add_result = {
        let mut blockchain = state.blockchain.lock().unwrap();
        blockchain.add_transaction(transaction.clone())
    };
    
    match add_result {
        Ok(_) => {
            // Save transaction to database
            match state.storage.save_transaction(&transaction).await {
                Ok(tx_hash) => {
                    Ok(Json(TransactionResponse {
                        success: true,
                        message: "Transaction added successfully".to_string(),
                        transaction_id: Some(tx_hash),
                    }))
                }
                Err(e) => {
                    println!("Error saving transaction to database: {}", e);
                    Ok(Json(TransactionResponse {
                        success: false,
                        message: format!("Database error: {}", e),
                        transaction_id: None,
                    }))
                }
            }
        }
        Err(e) => {
            Ok(Json(TransactionResponse {
                success: false,
                message: e,
                transaction_id: None,
            }))
        }
    }
}

async fn mint_tokens(
    State(state): State<AppState>,
    Json(request): Json<ServerMintRequest>,
) -> Result<Json<MintResponse>, StatusCode> {
    println!("DEBUG: mint_tokens called with request: {:?}", request);
    println!("DEBUG: Request account: {}, amount: {}", request.account, request.amount);
    let mut blockchain = state.real_blockchain.lock().unwrap();
    
    // Mint XWV tokens by default
    let success = blockchain.mint_tokens(&request.account, request.amount, "XWV");
    
    if success {
        let new_balance = blockchain.get_balance(&request.account);
        
        // Also update database for persistence
        if let Err(e) = state.storage.update_balance(&request.account, new_balance.xwv as u64).await {
            println!("Warning: Failed to persist balance to database: {}", e);
        }
        
        println!("Minted {} XWV tokens to {} (total: {})", request.amount, request.account, new_balance.xwv);
        {Ok(Json(MintResponse {
            success: true,
            message: format!("Successfully minted {} XWV tokens to {}", request.amount, request.account),
        }))
    } else {
        {Ok(Json(MintResponse {
            success: false,
            message: "Failed to mint tokens".to_string(),
        })) }
    }
}

async fn get_balance(
    State(state): State<AppState>,
    Path(address): Path<String>,
) -> Result<Json<BalanceResponse>, StatusCode> {
    println!("üîç Getting balance for address: {}", address);
    
    let blockchain = state.real_blockchain.lock().unwrap();
    let balance = blockchain.get_balance(&address);
    
    println!("üìä Blockchain balance for {}: {} XWV, {} USXWV", address, balance.xwv, balance.usxwv);
    
    Ok(Json(BalanceResponse {
        address,
        balance: balance.xwv.round() as u64,
    }))
}

// Block production task
async fn block_production_task(state: AppState) {
    let mut interval = time::interval(Duration::from_secs(10)); // Produce block every 10 seconds
    
    loop {
        interval.tick().await;
        
        // Get blockchain data and release lock before async operations
        let (transactions, previous_hash, current_height) = {
            let mut blockchain = state.blockchain.lock().unwrap();
            let current_height = blockchain.chain.len() as i64;
            
            if !blockchain.pending_transactions.is_empty() {
                let transactions = blockchain.pending_transactions.clone();
                blockchain.pending_transactions.clear();
                let previous_hash = blockchain.get_latest_block().hash.clone();
                (Some(transactions), previous_hash, current_height)
            } else {
                // Skip creating empty blocks unless it's been more than 30 seconds since last block
                let last_block_timestamp = blockchain.get_latest_block().timestamp;
                let current_timestamp = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
                
                if current_timestamp - last_block_timestamp < 30 {
                    continue; // Skip this iteration
                }
                
                let previous_hash = blockchain.get_latest_block().hash.clone();
                (None, previous_hash, current_height)
            }
        };
        
        let timestamp = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        
        // Select validator using CPV consensus
        let selected_validator = {
            let mut cpv = state.cpv_consensus.lock().unwrap();
            match cpv.select_validator() {
                Ok(validator) => {
                    println!("üéØ CPV selected validator: {} (Type: {:?})",
                        validator.address, validator.validator_type);
                    Some(validator)
                },
                Err(e) => {
                    println!("‚ö†Ô∏è  CPV validator selection failed: {}", e);
                    None
                }
            }
        };

        let validator_address = selected_validator.as_ref()
            .map(|v| v.address.clone())
            .unwrap_or_else(|| "system".to_string());

        // Create new block
        let mut new_block = Block {
            timestamp,
            transactions: transactions.clone().unwrap_or_default(),
            previous_hash,
            hash: String::new(),
            validator: Some(validator_address.clone()),
        };
        
        new_block.hash = new_block.calculate_hash();
        
        // Record validation round in CPV consensus
        if let Some(validator) = &selected_validator {
            let mut cpv = state.cpv_consensus.lock().unwrap();
            cpv.record_validation_round(validator, new_block.hash.clone());
        }
        
        // Save block to database
        if let Err(e) = state.storage.save_block(&new_block, current_height).await {
            println!("Error saving block to database: {}", e);
        }
        
        // Update balances in database if there are transactions
        if let Some(ref transactions) = transactions {
            for transaction in transactions {
                let (from_balance, to_balance) = {
                    let blockchain = state.blockchain.lock().unwrap();
                    (blockchain.get_balance(&transaction.from), blockchain.get_balance(&transaction.to))
                };
                
                if let Err(e) = state.storage.update_balance(&transaction.from, from_balance).await {
                    println!("Error updating balance for {}: {}", transaction.from, e);
                }
                if let Err(e) = state.storage.update_balance(&transaction.to, to_balance).await {
                    println!("Error updating balance for {}: {}", transaction.to, e);
                }
            }
        }
        
        // Add block to blockchain
        {
            let mut blockchain = state.blockchain.lock().unwrap();
            blockchain.chain.push(new_block);
        }
        
        if let Some(ref transactions) = transactions {
            println!("New block created with {} transactions", transactions.len());
        } else {
            println!("Empty block created");
        }
    }
}

// Health check endpoint
async fn health_check() -> Result<Json<serde_json::Value>, StatusCode> {
    Ok(Json(serde_json::json!({
        "status": "healthy",
        "timestamp": SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),
        "service": "xwave-blockchain"
    })))
}

// WebSocket handler
async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<AppState>,
) -> axum::response::Response {
    ws.on_upgrade(|socket| websocket_connection(socket, state))
}

async fn websocket_connection(socket: WebSocket, _state: AppState) {
    let (mut sender, mut receiver) = socket.split();
    
    println!("New WebSocket connection established");
    
    // Send initial welcome message
    if let Err(e) = sender.send(Message::Text("Connected to XWave Blockchain".to_string())).await {
        println!("Error sending welcome message: {}", e);
        return;
    }
    
    // Handle incoming messages
    while let Some(msg) = receiver.next().await {
        match msg {
            Ok(Message::Text(text)) => {
                println!("Received WebSocket message: {}", text);
                
                // Echo back the message
                if let Err(e) = sender.send(Message::Text(format!("Echo: {}", text))).await {
                    println!("Error sending WebSocket message: {}", e);
                    break;
                }
            }
            Ok(Message::Close(_)) => {
                println!("WebSocket connection closed by client");
                break;
            }
            Ok(Message::Ping(_)) => {
                // Respond to ping with pong
                if let Err(e) = sender.send(Message::Pong(vec![])).await {
                    println!("Error sending pong: {}", e);
                    break;
                }
            }
            Ok(Message::Pong(_)) => {
                // Client sent pong, connection is alive
                println!("Received pong from client");
            }
            Ok(Message::Binary(_)) => {
                // Handle binary messages (not used in this implementation)
                println!("Received binary message from client");
            }
            Err(e) => {
                println!("WebSocket error: {}", e);
                break;
            }
        }
    }
    
    println!("WebSocket connection ended");
}


async fn get_pool(
    State(state): State<AppState>,
    Path(pool_id): Path<String>,
) -> Result<Json<PoolResponse>, StatusCode> {
    let dex = state.dex.lock().unwrap();
    
    match dex.get_pool(&pool_id) {
        Some(pool) => {
            Ok(Json(PoolResponse {
                success: true,
                pool: Some(serde_json::to_value(pool).unwrap_or(serde_json::Value::Null)),
                message: "Pool retrieved successfully".to_string(),
            }))
        }
        None => {
            Ok(Json(PoolResponse {
                success: false,
                pool: None,
                message: "Pool not found".to_string(),
            }))
        }
    }
}

async fn get_pools(
    State(state): State<AppState>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let dex = state.dex.lock().unwrap();
    let pools = dex.get_all_pools();
    
    let pools_json: Vec<serde_json::Value> = pools.iter()
        .map(|pool| serde_json::to_value(pool).unwrap_or(serde_json::Value::Null))
        .collect();
    
    Ok(Json(serde_json::json!({
        "success": true,
        "pools": pools_json,
        "total": pools_json.len(),
        "message": "Pools retrieved successfully"
    })))
}

// DEX handlers
async fn execute_swap(
    State(state): State<AppState>,
    Json(request): Json<SwapRequest>,
) -> Result<Json<SwapResponse>, StatusCode> {
    // Check if user has sufficient balance (release lock immediately)
    let has_balance = {
        let token = state.token.lock().unwrap();
        token.has_balance(&request.user, request.amount)
    };
    
    if !has_balance {
        return Ok(Json(SwapResponse {
            success: false,
            message: "Insufficient balance".to_string(),
            tx_hash: None,
            amount_received: None,
            price_impact: None,
        }));
    }
    
    // Convert to DEX types
    let dex_request = crate::dex::SwapRequest {
        from: request.from.clone(),
        to: request.to.clone(),
        amount: request.amount,
        min_received: request.min_received,
        user: request.user.clone(),
    };
    
    // Execute swap in DEX (release lock immediately)
    let swap_result = {
        let mut dex = state.dex.lock().unwrap();
        dex.execute_swap(dex_request)
    };
    
    match swap_result {
        Ok(swap_response) => {
            // Update token balances (release lock immediately)
            let transfer_result = {
                let mut token = state.token.lock().unwrap();
                token.transfer(&request.user, "DEX_CONTRACT", request.amount, "")
            };
            
            if let Err(e) = transfer_result {
                return Ok(Json(SwapResponse {
                    success: false,
                    message: format!("Failed to deduct balance: {}", e),
                    tx_hash: None,
                    amount_received: None,
                    price_impact: None,
                }));
            }
            
            // Credit the received tokens to user (release lock immediately)
            if let Some(amount_received) = swap_response.amount_received {
                let mint_result = {
                    let mut token = state.token.lock().unwrap();
                    token.mint(&request.user, amount_received)
                };
                
                if let Err(e) = mint_result {
                    return Ok(Json(SwapResponse {
                        success: false,
                        message: format!("Failed to credit received tokens: {}", e),
                        tx_hash: None,
                        amount_received: None,
                        price_impact: None,
                    }));
                }
            }

            // Persist DEX transaction to PostgreSQL
            if let Some(tx_hash) = &swap_response.tx_hash {
                let pool_id = format!("{}_{}", request.from, request.to);
                let amount_received = swap_response.amount_received.unwrap_or(0.0);
                if let Err(e) = state.storage.save_dex_transaction(
                    tx_hash,
                    &request.user,
                    "DEX_CONTRACT",
                    request.amount as i64,
                    amount_received as i64,
                    &pool_id,
                    "swap"
                ).await {
                    println!("‚ö†Ô∏è  Failed to save DEX transaction to DB: {}", e);
                } else {
                    println!("‚úÖ DEX transaction saved to DB: {}", tx_hash);
                }

                // Update balances in PostgreSQL
                let current_balance = {
                    let token = state.token.lock().unwrap();
                    token.balance_of(&request.user) as u64
                };
                
                if let Err(e) = state.storage.update_balance(&request.user, current_balance).await {
                    println!("‚ö†Ô∏è  Failed to update balance in DB: {}", e);
                }
            }
            
            // Convert DEX response to server response
            let server_response = SwapResponse {
                success: swap_response.success,
                message: swap_response.message,
                tx_hash: swap_response.tx_hash,
                amount_received: swap_response.amount_received,
                price_impact: swap_response.price_impact,
            };
            Ok(Json(server_response))
        }
        Err(e) => {
            Ok(Json(SwapResponse {
                success: false,
                message: e,
                tx_hash: None,
                amount_received: None,
                price_impact: None,
            }))
        }
    }
}

async fn add_liquidity(
    State(state): State<AppState>,
    Json(request): Json<LiquidityRequest>,
) -> Result<Json<LiquidityResponse>, StatusCode> {
    // Check if user has sufficient balances for both tokens
    if request.amounts.len() != 2 {
        return Ok(Json(LiquidityResponse {
            success: false,
            message: "Must provide exactly 2 amounts".to_string(),
            tx_hash: None,
            lp_tokens_minted: None,
        }));
    }
    
    let amount_a = request.amounts[0];
    let amount_b = request.amounts[1];
    
    // Check balances (release lock immediately)
    let (has_balance_a, has_balance_b) = {
        let token = state.token.lock().unwrap();
        (token.has_balance(&request.user, amount_a), token.has_balance(&request.user, amount_b))
    };
    
    // For simplicity, we'll assume the pool uses XWAVE and USDC
    // In a real implementation, you'd get the token types from the pool
    if !has_balance_a {
        return Ok(Json(LiquidityResponse {
            success: false,
            message: "Insufficient balance for token A".to_string(),
            tx_hash: None,
            lp_tokens_minted: None,
        }));
    }
    
    if !has_balance_b {
        return Ok(Json(LiquidityResponse {
            success: false,
            message: "Insufficient balance for token B".to_string(),
            tx_hash: None,
            lp_tokens_minted: None,
        }));
    }
    
    // Convert to DEX types
    let dex_request = crate::dex::LiquidityRequest {
        pool_id: request.pool_id.clone(),
        amounts: request.amounts.clone(),
        user: request.user.clone(),
    };
    
    // Execute liquidity addition in DEX (release lock immediately)
    let liquidity_result = {
        let mut dex = state.dex.lock().unwrap();
        dex.add_liquidity(dex_request)
    };
    
    match liquidity_result {
        Ok(liquidity_response) => {
            // Deduct tokens from user (release lock immediately)
            let transfer_a_result = {
                let mut token = state.token.lock().unwrap();
                token.transfer(&request.user, "DEX_CONTRACT", amount_a, "")
            };
            
            if let Err(e) = transfer_a_result {
                return Ok(Json(LiquidityResponse {
                    success: false,
                    message: format!("Failed to deduct token A: {}", e),
                    tx_hash: None,
                    lp_tokens_minted: None,
                }));
            }
            
            let transfer_b_result = {
                let mut token = state.token.lock().unwrap();
                token.transfer(&request.user, "DEX_CONTRACT", amount_b, "")
            };
            
            if let Err(e) = transfer_b_result {
                return Ok(Json(LiquidityResponse {
                    success: false,
                    message: format!("Failed to deduct token B: {}", e),
                    tx_hash: None,
                    lp_tokens_minted: None,
                }));
            }

            // Persist liquidity transaction to PostgreSQL
            if let Some(tx_hash) = &liquidity_response.tx_hash {
                if let Err(e) = state.storage.save_dex_transaction(
                    tx_hash,
                    &request.user,
                    "DEX_CONTRACT",
                    (amount_a + amount_b) as i64,
                    0, // No output amount for liquidity
                    &request.pool_id,
                    "liquidity_add"
                ).await {
                    println!("‚ö†Ô∏è  Failed to save liquidity transaction to DB: {}", e);
                } else {
                    println!("‚úÖ Liquidity transaction saved to DB: {}", tx_hash);
                }

                // Save liquidity position
                if let Some(lp_tokens) = liquidity_response.lp_tokens_minted {
                    let position_id = format!("{}_{}", request.user, request.pool_id);
                    if let Err(e) = state.storage.save_liquidity_position(
                        &position_id,
                        &request.user,
                        &request.pool_id,
                        lp_tokens as i64
                    ).await {
                        println!("Failed to save liquidity position to DB: {}", e);
                    } else {
                        println!("Liquidity position saved to DB: {}", position_id);
                    }
                }

                // Update balances in PostgreSQL
                let current_balance = {
                    let token = state.token.lock().unwrap();
                    token.balance_of(&request.user) as u64
                };
                
                if let Err(e) = state.storage.update_balance(&request.user, current_balance).await {
                    println!("‚ö†Ô∏è  Failed to update balance in DB: {}", e);
                }
            }
            
            // Convert DEX response to server response
            let server_response = LiquidityResponse {
                success: liquidity_response.success,
                message: liquidity_response.message,
                tx_hash: liquidity_response.tx_hash,
                lp_tokens_minted: liquidity_response.lp_tokens_minted,
            };
            Ok(Json(server_response))
        }
        Err(e) => {
            Ok(Json(LiquidityResponse {
                success: false,
                message: e,
                tx_hash: None,
                lp_tokens_minted: None,
            }))
        }
    }
}

// Wallet handlers
async fn connect_wallet(
    Json(request): Json<ConnectWalletRequest>,
) -> Result<Json<ConnectWalletResponse>, StatusCode> {
    match wallet_handlers::connect_wallet(request).await {
        Ok(response) => Ok(Json(response)),
        Err(e) => {
            println!("Error connecting wallet: {}", e);
            Err(StatusCode::BAD_REQUEST)
        }
    }
}

async fn get_wallet_session(
    Query(params): Query<std::collections::HashMap<String, String>>,
) -> Result<Json<WalletSession>, StatusCode> {
    let session_id = params.get("session_id")
        .ok_or(StatusCode::BAD_REQUEST)?;
    
    match wallet_handlers::get_wallet_session(session_id.clone()).await {
        Ok(session) => Ok(Json(session)),
        Err(e) => {
            println!("Error getting wallet session: {}", e);
            Err(StatusCode::NOT_FOUND)
        }
    }
}

async fn disconnect_wallet(
    Json(request): Json<serde_json::Value>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let session_id = request.get("session_id")
        .and_then(|v| v.as_str())
        .ok_or(StatusCode::BAD_REQUEST)?;
    
    match wallet_handlers::disconnect_wallet(session_id.to_string()).await {
        Ok(message) => Ok(Json(serde_json::json!({
            "success": true,
            "message": message
        }))),
        Err(e) => {
            println!("Error disconnecting wallet: {}", e);
            Err(StatusCode::BAD_REQUEST)
        }
    }
}

// Admin wallet connection
async fn connect_admin_wallet() -> Result<Json<ConnectWalletResponse>, StatusCode> {
    let admin_address = std::env::var("ADMIN_WALLET_ADDRESS")
        .unwrap_or_else(|_| "0x742d35Cc6634C0532925a3b8D0c0f7c6c7B9B5f8".to_string());

    let request = ConnectWalletRequest {
        wallet_type: "admin".to_string(),
        address: Some(admin_address.clone()),
        signature: None,
    };

    match wallet_handlers::connect_wallet(request).await {
        Ok(response) => Ok(Json(response)),
        Err(e) => {
            println!("Error connecting admin wallet: {}", e);
            Err(StatusCode::INTERNAL_SERVER_ERROR)
        }
    }
}

// Staking endpoints

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerStakeRequest {
    pub account: String,
    pub amount: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerUnstakeRequest {
    pub account: String,
    pub amount: f64,
}

#[derive(Serialize)]
pub struct StakeResponse {
    pub success: bool,
    pub message: String,
    pub tx_hash: Option<String>,
    pub new_balance: Option<f64>,
}

// CPV Consensus request/response types
#[derive(Deserialize)]
pub struct EconomicValidatorRequest {
    pub address: String,
    pub stake: u64,
}

#[derive(Deserialize)]
pub struct CreativeValidatorRequest {
    pub address: String,
    pub verified_nfts: Vec<String>,
}

#[derive(Deserialize)]
pub struct CommunityValidatorRequest {
    pub address: String,
}

#[derive(Serialize)]
pub struct ConsensusStatsResponse {
    pub economic_validators: usize,
    pub creative_validators: usize,
    pub community_validators: usize,
    pub total_validation_rounds: usize,
    pub economic_validations: usize,
    pub creative_validations: usize,
    pub community_validations: usize,
}

#[derive(Serialize)]
pub struct ValidatorRegistrationResponse {
    pub success: bool,
    pub message: String,
    pub validator_type: String,
}

// Real staking handlers
async fn simple_stake_handler(
    State(state): State<AppState>,
    Json(request): Json<ServerStakeRequest>,
) -> Result<Json<StakeResponse>, StatusCode> {
    let mut blockchain = state.real_blockchain.lock().unwrap();
    
    match blockchain.stake_tokens(&request.account, request.amount) {
        Ok(result) => {
            let new_balance = blockchain.get_balance(&request.account);
            let tx_hash = format!("STAKE_{}_{}", request.account, SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs());
            
            Ok(Json(StakeResponse {
                success: result.success,
                message: if result.success {
                    format!("Successfully staked {} XWV tokens", request.amount)
                } else {
                    result.error.unwrap_or("Staking failed".to_string())
                },
                tx_hash: if result.success { Some(tx_hash) } else { None },
                new_balance: Some(new_balance.xwv),
            })) }
        },
        Err(e) => {
            {Ok(Json(StakeResponse {
                success: false,
                message: format!("Staking error: {}", e),
                tx_hash: None,
                new_balance: None,
            })) }
        },
    }
}

async fn simple_unstake_handler(
    State(state): State<AppState>,
    Json(request): Json<ServerUnstakeRequest>,
) -> Result<Json<StakeResponse>, StatusCode> {
    let mut blockchain = state.real_blockchain.lock().unwrap();
    
    // For unstaking, we need a position ID. For now, we'll find the first active position
    let positions = blockchain.get_staking_positions(&request.account);
    let active_position = positions.iter().find(|p| p.is_active);
    
    if let Some(position) = active_position {
        match blockchain.unstake_tokens(&request.account, &position.id) {
            Ok(result) => {
                let new_balance = blockchain.get_balance(&request.account);
                let tx_hash = format!("UNSTAKE_{}_{}", request.account, SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs());
                
                {Ok(Json(StakeResponse {
                    success: result.success,
                    message: if result.success {
                        format!("Successfully unstaked {} XWV tokens + {} rewards", 
                               result.amount.unwrap_or(0.0), 
                               result.rewards.unwrap_or(0.0))
                    } else {
                        result.error.unwrap_or("Unstaking failed".to_string())
                    },
                    tx_hash: if result.success { Some(tx_hash) } else { None },
                    new_balance: Some(new_balance.xwv),
                })) }
            }
            Err(e) => {
                {Ok(Json(StakeResponse {
                    success: false,
                    message: format!("Unstaking error: {}", e),
                    tx_hash: None,
                    new_balance: None,
                })) }
            }
        }
    } else {
        {Ok(Json(StakeResponse {
            success: false,
            message: "No active staking position found".to_string(),
            tx_hash: None,
            new_balance: None,
        })) }
    }
}

// Real swap handler
#[derive(Deserialize)]
pub struct RealSwapRequest {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub min_received: f64,
    pub user: String,
}

#[derive(Serialize)]
pub struct RealSwapResponse {
    pub success: bool,
    pub message: String,
    pub amount_in: Option<f64>,
    pub amount_out: Option<f64>,
    pub price_impact: Option<f64>,
    pub fee: Option<f64>,
    pub tx_hash: Option<String>,
}

async fn real_swap_handler(
    State(state): State<AppState>,
    Json(request): Json<RealSwapRequest>,
) -> Result<Json<StakeResponse>, StatusCode> {
    let mut blockchain = state.real_blockchain.lock().unwrap();
    
    // Determine token types from request
    let from_token = if request.from == "XWV" { "XWV" } else { "USXWV" };
    let to_token = if request.to == "XWV" { "XWV" } else { "USXWV" };
    
    match blockchain.swap_tokens(&request.user, from_token, to_token, request.amount, request.min_received) {
        Ok(result) => {
            let tx_hash = format!("SWAP_{}_{}", request.user, SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs());
            
            Ok(Json(RealSwapResponse {
                success: result.success,
                message: if result.success {
                    format!("Successfully swapped {} {} to {} {}",
                           result.amount_in, from_token, result.amount_out, to_token)
                } else {
                    result.error.unwrap_or("Swap failed".to_string())
                },
                amount_in: Some(result.amount_in),
                amount_out: Some(result.amount_out),
                price_impact: Some(result.price_impact),
                fee: Some(result.fee),
                tx_hash: if result.success { Some(tx_hash) } else { None },
            }))
        }
        Err(e) => {
            Ok(Json(RealSwapResponse {
                success: false,
                message: format!("Swap error: {}", e),
                amount_in: None,
                amount_out: None,
                price_impact: None,
                fee: None,
                tx_hash: None,
            }))
        }
    }
}


// Native functionality handlers
// Vesting handlers
async fn create_vesting_schedule(
    State(state): State<AppState>,
    Json(request): Json<CreateVestingRequest>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let mut vesting_manager = state.vesting_manager.lock().unwrap();
    
    match vesting_manager.create_vesting_schedule(request) {
        Ok(response) => Ok(Json(serde_json::json!({
            "success": response.success,
            "message": response.message,
            "data": response.data
        }))),
        Err(e) => Ok(Json(serde_json::json!({
            "success": false,
            "message": e
        })))
    }
}

async fn release_vested_tokens(
    State(state): State<AppState>,
    Json(request): Json<ReleaseVestingRequest>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let mut vesting_manager = state.vesting_manager.lock().unwrap();
    
    match vesting_manager.release_vested_tokens(request) {
        Ok(response) => Ok(Json(serde_json::json!({
            "success": response.success,
            "message": response.message,
            "data": response.data
        }))),
        Err(e) => Ok(Json(serde_json::json!({
            "success": false,
            "message": e
        })))
    }
}

async fn get_vesting_schedules(
    State(state): State<AppState>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let vesting_manager = state.vesting_manager.lock().unwrap();
    let stats = vesting_manager.get_detailed_stats();
    
    Ok(Json(stats))
}

// Multisig handlers
async fn create_multisig_transaction(
    State(state): State<AppState>,
    Json(request): Json<MultisigRequest>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let mut multisig = state.multisig_wallet.lock().unwrap();
    
    match multisig.create_transaction(request) {
        Ok(response) => Ok(Json(serde_json::json!({
            "success": response.success,
            "message": response.message,
            "tx_hash": response.tx_hash,
            "data": response.data
        }))),
        Err(e) => Ok(Json(serde_json::json!({
            "success": false,
            "message": e
        })))
    }
}

async fn sign_multisig_transaction(
    State(state): State<AppState>,
    Json(request): Json<SignRequest>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let mut multisig = state.multisig_wallet.lock().unwrap();
    
    match multisig.sign_transaction(request) {
        Ok(response) => Ok(Json(serde_json::json!({
            "success": response.success,
            "message": response.message,
            "tx_hash": response.tx_hash,
            "data": response.data
        }))),
        Err(e) => Ok(Json(serde_json::json!({
            "success": false,
            "message": e
        })))
    }
}

async fn get_multisig_info(
    State(state): State<AppState>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let multisig = state.multisig_wallet.lock().unwrap();
    let info = multisig.get_info();
    
    Ok(Json(info))
}

// Native token handlers
async fn create_native_vesting(
    State(state): State<AppState>,
    Json(request): Json<VestingRequest>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let mut native_token = state.native_token.lock().unwrap();
    
    match native_token.create_vesting_schedule(request) {
        Ok(response) => Ok(Json(serde_json::json!({
            "success": response.success,
            "message": response.message,
            "tx_hash": response.tx_hash,
            "data": response.data
        }))),
        Err(e) => Ok(Json(serde_json::json!({
            "success": false,
            "message": e
        })))
    }
}

async fn release_native_vested(
    State(state): State<AppState>,
    Path(beneficiary): Path<String>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let mut native_token = state.native_token.lock().unwrap();
    
    match native_token.release_vested_tokens(&beneficiary) {
        Ok(response) => Ok(Json(serde_json::json!({
            "success": response.success,
            "message": response.message,
            "tx_hash": response.tx_hash,
            "data": response.data
        }))),
        Err(e) => Ok(Json(serde_json::json!({
            "success": false,
            "message": e
        })))
    }
}

async fn get_native_token_stats(
    State(state): State<AppState>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let native_token = state.native_token.lock().unwrap();
    let stats = native_token.get_token_stats();
    
    Ok(Json(stats))
}

// Supply distribution endpoint
async fn get_supply_distribution(
    State(state): State<AppState>,
) -> Result<Json<serde_json::Value>, StatusCode> {
    let token = state.token.lock().unwrap();
    let (total_holders, total_balance, total_nfts, total_royalties) = token.get_stats();

    // Get detailed balance distribution
    let mut distribution = Vec::new();
    let mut total_distributed = 0.0;

    for (address, balance) in &token.balances {
        if *balance > 0.0 {
            let percentage = if total_balance > 0.0 {
                (*balance / total_balance) * 100.0
            } else {
                0.0
            };

            distribution.push(serde_json::json!({
                "address": &address[..if address.len() > 10 { 10 } else { address.len() }],
                "full_address": address,
                "balance": balance,
                "percentage": percentage
            }));

            total_distributed += balance;
        }
    }

    // Sort by balance descending
    distribution.sort_by(|a, b| {
        b["balance"].as_f64().unwrap().partial_cmp(&a["balance"].as_f64().unwrap()).unwrap()
    });

    Ok(Json(serde_json::json!({
        "success": true,
        "total_supply": total_balance,
        "total_holders": total_holders,
        "total_nfts": total_nfts,
        "total_royalties": total_royalties,
        "total_distributed": total_distributed,
        "distribution_percentage": if total_balance > 0.0 { (total_distributed / total_balance) * 100.0 } else { 0.0 },
        "top_holders": distribution,
        "message": "Supply distribution retrieved successfully"
    })))
}

// Create the router
pub fn create_router(state: AppState) -> Router {
    let jwt_config = state.jwt_config.clone();
    
    // Public routes (no authentication required)
    let public_routes = Router::new()
        .route("/health", get(health_check))
        .route("/blocks", get(get_blocks))
        .route("/transactions", get(get_transactions))
        .route("/balance/:address", get(get_balance))
        .route("/pools", get(get_pools))
        .route("/pool/:id", get(get_pool))
        .route("/token/stats", get(get_token_stats))
        .route("/ws", get(websocket_handler))
        .route("/login", post(login_handler))
        .route("/test", get(|| async { Json(serde_json::json!({"message": "Test is working!"})) }))
        .route("/api/wallet/connect", post(connect_wallet))
        .route("/api/wallet/connect/admin", post(connect_admin_wallet))
        .route("/api/wallet/session", get(get_wallet_session))
        .route("/api/wallet/disconnect", post(disconnect_wallet))
        // Native functionality routes (public for testing)
        .route("/native/token/stats", get(get_native_token_stats))
        .route("/supply/distribution", get(get_supply_distribution))
        .route("/vesting/schedules", get(get_vesting_schedules))
        .route("/multisig/info", get(get_multisig_info));
    
    // Protected routes (require JWT authentication)
    let protected_routes = Router::new()
        .route("/transaction", post(submit_transaction))
        .route("/mint", post(mint_tokens))
        .route("/liquidity/add", post(add_liquidity))
        .route("/consensus/stats", get(get_consensus_stats))
        .route("/consensus/register/economic", post(register_economic_validator))
        .route("/consensus/register/creative", post(register_creative_validator))
        .route("/consensus/register/community", post(register_community_validator))
        .route("/stake", post(simple_stake_handler))
        .route("/unstake", post(simple_unstake_handler))
        .route("/swap", post(real_swap_handler))
        // Native functionality routes (protected)
        .route("/vesting/create", post(create_vesting_schedule))
        .route("/vesting/release", post(release_vested_tokens))
        .route("/multisig/create", post(create_multisig_transaction))
        .route("/multisig/sign", post(sign_multisig_transaction))
        .route("/native/vesting/create", post(create_native_vesting))
        .route("/native/vesting/release/:beneficiary", post(release_native_vested))
        .route_layer(axum::middleware::from_fn_with_state(
            jwt_config,
            jwt_middleware,
        ));
    
    // Combine public and protected routes
    public_routes
        .merge(protected_routes)
        .layer(CorsLayer::permissive())
        .layer(TimeoutLayer::new(Duration::from_secs(30)))
        .with_state(state)
}

// Start the server
pub async fn start_server() -> Result<(), Box<dyn std::error::Error>> {
    // Load environment variables
    dotenv::dotenv().ok();
    
    // Get database URL from environment
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://yare@localhost:5432/xwave_blockchain".to_string());
    
    println!("üóÑÔ∏è  Connecting to database: {}", database_url);
    
    // Initialize database storage
    let storage: Arc<BlockchainStorage> = Arc::new(BlockchainStorage::new(&database_url).await?);
    storage.init_tables().await?;
    println!("Database tables initialized");
    
    
    // Load blockchain from database or create new one
    let blockchain = match storage.load_blockchain().await {
        Ok(loaded_blockchain) => {
            println!("üìö Loaded blockchain from database with {} blocks", loaded_blockchain.chain.len());
            Arc::new(Mutex::new(loaded_blockchain))
        }
        Err(e) => {
            println!(" Could not load blockchain from database: {}", e);
            println!("Creating new blockchain");
            Arc::new(Mutex::new(Blockchain::new()))
        }
    };
    
    let token = Arc::new(Mutex::new(Token::new()));
    
    // Load all balances from database into token system
    println!("üîÑ Loading balances from database...");
    match storage.get_all_balances().await {
        Ok(balances) => {
            let balance_count = balances.len();
            let mut token_guard = token.lock().unwrap();
            for (address, balance) in balances {
                if balance > 0 {
                    // Use mint to set balance in token system
                    if let Err(e) = token_guard.mint(&address, balance as f64) {
                        println!("‚ö†Ô∏è Warning: Failed to load balance for {}: {}", address, e);
                    } else {
                        println!("üí∞ Loaded balance for {}: {}", address, balance);
                    }
                }
            }
            println!("‚úÖ Loaded {} balances from database", balance_count);
        }
        Err(e) => {
            println!("‚ö†Ô∏è Warning: Failed to load balances from database: {}", e);
        }
    }
    
    // Initialize staking contract with zero balance
    {
        let mut token_guard = token.lock().unwrap();
        if token_guard.balance_of("STAKING_CONTRACT") == 0.0 {
            // Mint zero balance to ensure the contract exists
            let _ = token_guard.mint("STAKING_CONTRACT", 0.0);
            println!("üè¶ Staking contract initialized");
        }
    }
    
    let dex = Arc::new(Mutex::new(DEX::new()));
    let websocket_clients = Arc::new(Mutex::new(Vec::new()));
    let jwt_config = JwtConfig::new();
    
    let cpv_consensus = Arc::new(Mutex::new(CPVConsensus::new()));
    
    // Initialize native functionalities
    let native_token = Arc::new(Mutex::new(NativeToken::new("ADMIN_ADDRESS".to_string())));
    let multisig_wallet = Arc::new(Mutex::new(MultisigWallet::new(
        "Treasury Multisig".to_string(),
        "TREASURY".to_string(),
        vec![
            "ADMIN_ADDRESS".to_string(),
            "TREASURY_1".to_string(),
            "TREASURY_2".to_string(),
            "TREASURY_3".to_string(),
            "TREASURY_4".to_string(),
        ],
        3, // 3/5 threshold
        1000000, // daily limit
    ).unwrap()));
    let vesting_manager = Arc::new(Mutex::new(VestingManager::new()));
    
    // Initialize real blockchain
    let real_blockchain = Arc::new(Mutex::new(RealBlockchain::new()));
    
    let state = AppState {
        blockchain: blockchain.clone(),
        token: token.clone(),
        dex: dex.clone(),
        websocket_clients: websocket_clients.clone(),
        storage: storage.clone(),
        jwt_config: jwt_config.clone(),
        cpv_consensus: cpv_consensus.clone(),
        // Real blockchain implementation
        real_blockchain: real_blockchain.clone(),
    // Native functionalities
    native_token: native_token.clone(),
    multisig_wallet: multisig_wallet.clone(),
    vesting_manager: vesting_manager.clone(),
    };
    
    // Start block production task
    let state_for_task = state.clone();
    tokio::spawn(async move {
        block_production_task(state_for_task).await;
    });
    
    // Create router
    let app = create_router(state);
    
    // Start server
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8083").await?;
    println!("XWave Blockchain Server starting on http://0.0.0.0:8083");
    println!("Available endpoints:");
    println!("   GET  /health - Health check");
    println!("   GET  /blocks - Get blockchain");
    println!("   POST /transaction - Submit transaction");
    println!("   POST /mint - Mint tokens");
    println!("   GET  /balance/{{address}} - Get balance");
    println!("   GET  /pool/{{id}} - Get pool information");
    println!("   POST /swap - Execute token swap (JWT protected)");
    println!("   POST /liquidity/add - Add liquidity (JWT protected)");
    println!("   WS   /ws - WebSocket for real-time updates");
    println!("Block production: every 10 seconds");
    
    axum::serve(listener, app).await?;
    
    Ok(())
}

// Original staking handlers
async fn stake_tokens(
    State(state): State<AppState>,
    Json(request): Json<ServerStakeRequest>,
) -> Result<Json<StakeResponse>, StatusCode> {
    let mut token = state.token.lock().unwrap();
    let mut cpv = state.cpv_consensus.lock().unwrap();

    // Check if user has sufficient balance
    let current_balance = token.balance_of(&request.account);
    if current_balance < request.amount {
        return Ok(Json(StakeResponse {
            success: false,
            message: "Insufficient balance for staking".to_string(),
            tx_hash: None,
            new_balance: None,
        }));
    }

    // Deduct tokens from balance (stake them)
    let stake_amount = request.amount as u64;
    match token.transfer(&request.account, "STAKING_CONTRACT", stake_amount as f64, "Staking") {
        Ok(_) => {
            // Register or update economic validator
            let _ = cpv.register_economic_validator(request.account.clone(), stake_amount);

            // Update economic activity score
            cpv.update_economic_activity(&request.account, request.amount * 0.1);

            let new_balance = token.balance_of(&request.account);

            // Persist the new balance to database
            if let Err(e) = state.storage.update_balance(&request.account, new_balance as u64).await {
                println!("Warning: Failed to persist balance to database: {}", e);
            }

            let tx_hash = format!("STAKE_{}_{}", request.account, SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs());

            Ok(Json(StakeResponse {
                success: true,
                message: format!("Successfully staked {} XWV tokens", request.amount),
                tx_hash: Some(tx_hash),
                new_balance: Some(new_balance as f64),
            }))
        }
        Err(e) => {
            Ok(Json(StakeResponse {
                success: false,
                message: e,
                tx_hash: None,
                new_balance: None,
            }))
        }
    }
}

async fn unstake_tokens(
    State(state): State<AppState>,
    Json(request): Json<ServerUnstakeRequest>,
) -> Result<Json<StakeResponse>, StatusCode> {
    let mut token = state.token.lock().unwrap();
    let mut cpv = state.cpv_consensus.lock().unwrap();

    // Return tokens to user balance from staking contract
    let unstake_amount = request.amount as u64;
    match token.transfer("STAKING_CONTRACT", &request.account, unstake_amount as f64, "Unstaking") {
        Ok(_) => {
            // Update economic activity score (reduce for unstaking)
            cpv.update_economic_activity(&request.account, -request.amount * 0.05);

            let new_balance = token.balance_of(&request.account);

            // Persist the new balance to database
            if let Err(e) = state.storage.update_balance(&request.account, new_balance as u64).await {
                println!("Warning: Failed to persist balance to database: {}", e);
            }

            let tx_hash = format!("UNSTAKE_{}_{}", request.account, SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs());

            Ok(Json(StakeResponse {
                success: true,
                message: format!("Successfully unstaked {} XWV tokens", request.amount),
                tx_hash: Some(tx_hash),
                new_balance: Some(new_balance as f64),
            }))
        }
        Err(e) => {
            Ok(Json(StakeResponse {
                success: false,
                message: e,
                tx_hash: None,
                new_balance: None,
            }))
        }
    }
}

// CPV Consensus endpoints
async fn get_consensus_stats(
    State(state): State<AppState>,
) -> Result<Json<ConsensusStatsResponse>, StatusCode> {
    let cpv = state.cpv_consensus.lock().unwrap();
    let stats = cpv.get_consensus_stats();

    Ok(Json(ConsensusStatsResponse {
        economic_validators: stats.get("economic_validators").unwrap().as_u64().unwrap() as usize,
        creative_validators: stats.get("creative_validators").unwrap().as_u64().unwrap() as usize,
        community_validators: stats.get("community_validators").unwrap().as_u64().unwrap() as usize,
        total_validation_rounds: stats.get("total_validation_rounds").unwrap().as_u64().unwrap() as usize,
        economic_validations: stats.get("economic_validations").unwrap().as_u64().unwrap() as usize,
        creative_validations: stats.get("creative_validations").unwrap().as_u64().unwrap() as usize,
        community_validations: stats.get("community_validations").unwrap().as_u64().unwrap() as usize,
    }))
}

async fn register_economic_validator(
    State(state): State<AppState>,
    Json(request): Json<EconomicValidatorRequest>,
) -> Result<Json<ValidatorRegistrationResponse>, StatusCode> {
    let mut cpv = state.cpv_consensus.lock().unwrap();

    match cpv.register_economic_validator(request.address.clone(), request.stake) {
        Ok(_) => Ok(Json(ValidatorRegistrationResponse {
            success: true,
            message: format!("Economic validator {} registered successfully", request.address),
            validator_type: "Economic".to_string(),
        })),
        Err(e) => Ok(Json(ValidatorRegistrationResponse {
            success: false,
            message: e,
            validator_type: "Economic".to_string(),
        })),
    }
}

async fn register_creative_validator(
    State(state): State<AppState>,
    Json(request): Json<CreativeValidatorRequest>,
) -> Result<Json<ValidatorRegistrationResponse>, StatusCode> {
    let mut cpv = state.cpv_consensus.lock().unwrap();

    match cpv.register_creative_validator(request.address.clone(), request.verified_nfts) {
        Ok(_) => Ok(Json(ValidatorRegistrationResponse {
            success: true,
            message: format!("Creative validator {} registered successfully", request.address),
            validator_type: "Creative".to_string(),
        })),
        Err(e) => Ok(Json(ValidatorRegistrationResponse {
            success: false,
            message: e,
            validator_type: "Creative".to_string(),
        })),
    }
}

async fn register_community_validator(
    State(state): State<AppState>,
    Json(request): Json<CommunityValidatorRequest>,
) -> Result<Json<ValidatorRegistrationResponse>, StatusCode> {
    let mut cpv = state.cpv_consensus.lock().unwrap();

    match cpv.register_community_validator(request.address.clone()) {
        Ok(_) => Ok(Json(ValidatorRegistrationResponse {
            success: true,
            message: format!("Community validator {} registered successfully", request.address),
            validator_type: "Community".to_string(),
        })),
        Err(e) => Ok(Json(ValidatorRegistrationResponse {
            success: false,
            message: e,
            validator_type: "Community".to_string(),
        })),
    }
}




